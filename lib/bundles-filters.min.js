const mm=require("micromatch"),bundles=require("@bundles/core");module.exports=((r={},e={})=>{if(e.filters instanceof Object&&e.filters.constructor===Object&&(e.filters=[e.filters]),!(e.filters instanceof Array))return r.errors.push(new Error(`[${r.id}] Skipped \`bundles-filter\` bundler. \`bundler.filters\` must be an Object or Array of Objects or Arrays.`)),r;const t=r.bundlers.slice(0);return e.filters.reduce((r,e,n)=>r.then(r=>{if((e instanceof Array||"string"==typeof e||"function"==typeof e)&&(e={pattern:e}),!e.pattern)return r.errors.push(new Error(`[${r.id}] Skipped filter ${n}. \`filter.pattern\` must exist.`)),r;if("string"!=typeof e.pattern&&!(e.pattern instanceof Array)&&"function"!=typeof e.pattern)return r.errors.push(new Error(`[${r.id}] Skipped filter \`${e.pattern}\`. Pattern must be a String, Array, or custom Function.`)),r;const s=r.output.filter(t=>{let n="function"==typeof e.pattern?e.pattern(t,{bundle:r,micromatch:mm}):mm[["every","any","all","not","contains","some"].includes(e.type)?e.type:"some"](t.source.path,e.pattern,e.options||{});return e.reverse&&(n=!n),n});if(e.bundlers instanceof Array&&e.bundlers.length){e.bundlers=e.bundlers.map((r,e)=>bundles.resolveBundler(r));const n=r.output;return r.bundlers=e.bundlers,r.output=s,bundles.run(r).then(r=>(r.bundlers=t,r.output=n,r))}return r.output=s,r}),Promise.resolve(r))});